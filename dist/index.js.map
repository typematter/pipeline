{"version":3,"sources":["../src/lib/failure.ts","../src/lib/success.ts","../src/lib/compose.ts","../src/lib/resolve.ts"],"names":[],"mappings":";AAiBA,IAAM,aAAA,GAAN,cAA4B,KAAM,CAAA;AAAA,EACjC,YAAY,OAAiB,EAAA;AAC5B,IAAA,KAAA,CAAM,OAAO,CAAA;AACb,IAAA,IAAA,CAAK,IAAO,GAAA,eAAA;AAAA;AAEd,CAAA;AAoDM,IAAA,OAAA,GAAU,CAAI,KAA8C,MAAA;AAAA,EACjE,EAAI,EAAA,KAAA;AAAA,EACJ,KACC,EAAA,KAAA,YAAiB,aACd,GAAA,KAAA,GACA,IAAI,aAAA,CAAc,KAAiB,YAAA,KAAA,GAAQ,KAAM,CAAA,OAAA,GAAU,MAAO,CAAA,KAAK,CAAC;AAC7E,CAAA;;;ACtCA,IAAM,OAAA,GAAU,CAAI,KAAyB,MAAA;AAAA,EAC5C,EAAI,EAAA,IAAA;AAAA,EACJ;AACD,CAAA,CAAA;AAEA,IAAO,eAAQ,GAAA;;;ACwEf,IAAM,OAAA,GAAW,CAAC,MAAQ,EAAA,EAAE,QAAW,GAAA,EACtC,KAAA,OAAO,OAAY,KAAA;AAClB,EAAA,IAAI,cAAiB,GAAA,MAAA,KAAW,IAAO,GAAA,OAAA,GAAU,gBAAgB,OAAO,CAAA;AAExE,EAAA,KAAA,MAAW,SAAS,MAAQ,EAAA;AAC3B,IAAI,IAAA;AACH,MAAM,MAAA,MAAA,GAAS,MAAM,KAAA,CAAM,cAAc,CAAA;AAEzC,MAAA,IAAI,OAAO,EAAI,EAAA;AACd,QACC,cAAA,GAAA,MAAA,KAAW,OAAO,MAAO,CAAA,MAAA,CAAO,gBAAgB,MAAO,CAAA,KAAK,IAAI,MAAO,CAAA,KAAA;AAAA,OAClE,MAAA;AACN,QAAO,OAAA,MAAA;AAAA;AACR,aACQ,KAAO,EAAA;AACf,MAAA,OAAO,QAAQ,KAAK,CAAA;AAAA;AACrB;AAGD,EAAA,OAAO,gBAAQ,cAAc,CAAA;AAC9B,CAAA;AAED,IAAO,eAAQ,GAAA;;;AC7Ef,IAAM,OAAA,GAA6C,CAAC,MAAW,KAAA;AAC9D,EAAA,IAAI,OAAO,EAAI,EAAA;AACd,IAAA,OAAO,MAAO,CAAA,KAAA;AAAA,GACR,MAAA;AACN,IAAA,MAAM,MAAO,CAAA,KAAA;AAAA;AAEf,CAAA;AAEA,IAAO,eAAQ,GAAA","file":"index.js","sourcesContent":["import type { Result } from '$types/result.js';\n\n/**\n * Custom error class for pipeline-specific errors.\n * Extends the standard `Error` class to provide pipeline-specific error handling.\n *\n * @example\n * ```typescript\n * // Direct usage\n * throw new PipelineError('Data validation failed');\n *\n * // Checking error type\n * if (error instanceof PipelineError) {\n *   // Handle pipeline-specific error\n * }\n * ```\n */\nclass PipelineError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = 'PipelineError';\n\t}\n}\n\n/**\n * Creates a failure `Result` object, standardizing error handling within the pipeline.\n * This utility function ensures all errors are properly wrapped in a `PipelineError`\n * and converted to a failure Result.\n *\n * The function handles three types of error inputs:\n * 1. `PipelineError` instances (passed through as-is)\n * 2. Standard `Error` instances (message is extracted and wrapped in `PipelineError`)\n * 3. Any other value (converted to string and wrapped in `PipelineError`)\n *\n * @template T - The type parameter of the `Result` (unused in failure case but required for type compatibility)\n * @param error - The error value to wrap. Can be any type, but will be converted to `PipelineError`.\n * @returns A `Result` object with `ok: false` and a `PipelineError`\n *\n * @example\n * // With PipelineError\n * const result1 = failure(new PipelineError('Pipeline stage failed'));\n * // Result<T, PipelineError> with original PipelineError\n *\n * @example\n * // With standard Error\n * const result2 = failure(new Error('Something went wrong'));\n * // Result<T, PipelineError> with message \"Something went wrong\"\n *\n * @example\n * // With string\n * const result3 = failure('Invalid input');\n * // Result<T, PipelineError> with message \"Invalid input\"\n *\n * @example\n * // Usage in pipeline stage\n * const processDataStage: PipelineStage<DataContext> = async (context) => {\n *   try {\n *     // Processing logic\n *     return success({ ...context, processed: true });\n *   } catch (error) {\n *     return failure(error);\n *   }\n * };\n *\n * @example\n * // Using with custom error handling\n * const handleError = (error: unknown) => {\n *   console.error('Pipeline failed:', error);\n *   return failure(error);\n * };\n *\n * @see {@link Result} - The Result type this function creates\n * @see {@link PipelineError} - The custom error class used for standardization\n */\nconst failure = <T>(error: unknown): Result<T, PipelineError> => ({\n\tok: false,\n\terror:\n\t\terror instanceof PipelineError\n\t\t\t? error\n\t\t\t: new PipelineError(error instanceof Error ? error.message : String(error))\n});\n\nexport { failure as default, PipelineError };\n","import type { Result } from '$types/result.js';\n\n/**\n * Creates a successful `Result` object containing a value.\n * This is a utility function to create the success case of a `Result` type in\n * a more concise and type-safe way.\n *\n * @template T - The type of the success value\n * @param value - The value to wrap in a successful `Result` object\n * @returns A `Result` object with `ok: true` and the provided value\n *\n * @example\n * // Basic usage\n * const numberResult = success(42);\n * // Type: Result<number> = { ok: true, value: 42 }\n *\n * @example\n * // With complex types\n * interface UserData {\n *   id: string;\n *   name: string;\n * }\n *\n * const userData = success({\n *   id: \"42\",\n *   name: \"Alice\"\n * });\n * // Type: Result<UserData>\n *\n * @example\n * // Using in async functions\n * async function fetchUser(id: string): Promise<Result<UserData>> {\n *   try {\n *     const user = await db.users.find(id);\n *     return success(user);\n *   } catch (error) {\n *     return failure(error);\n *   }\n * }\n *\n * @see {@link Result} - The Result type this function creates\n */\nconst success = <T>(value: T): Result<T> => ({\n\tok: true,\n\tvalue\n});\n\nexport default success;\n","import type { PipelineContext } from '$types/pipeline-context.js';\nimport type { PipelineStage } from '$types/pipeline-stage.js';\nimport failure from './failure.js';\nimport success from './success.js';\n\n/**\n * Configuration options for the compose function.\n *\n * @property mutate - When true, allows direct mutation of the pipeline context\n *                    between stages instead of creating new context objects.\n *                    This can improve performance but sacrifices immutability.\n */\ntype ComposeOptions = {\n\tmutate?: true;\n};\n\n/**\n * Function type for composing multiple pipeline stages into a single stage.\n *\n * @template T - The specific PipelineContext type these stages operate on\n * @param stages - Array of pipeline stages to compose\n * @param options - Configuration options for composition behavior\n * @returns A single pipeline stage that executes all stages in sequence\n */\ntype Compose = <T extends PipelineContext = PipelineContext>(\n\tstages: PipelineStage<T>[],\n\toptions?: ComposeOptions\n) => PipelineStage<T>;\n\n/**\n * Composes multiple pipeline stages into a single stage that executes them in sequence.\n * This function provides a way to combine multiple processing steps into a single\n * pipeline stage while handling errors and context passing between stages.\n *\n * Key features:\n * - Sequential execution of stages\n * - Automatic error propagation\n * - Context passing between stages\n * - Optional mutation mode for performance\n * - Deep cloning of context by default\n *\n * @template T - The specific PipelineContext type these stages operate on\n * @param stages - Array of pipeline stages to execute in sequence\n * @param options - Configuration options:\n *                 - mutate: When true, allows direct mutation of context between stages\n * @returns A single pipeline stage that executes all stages in sequence\n *\n * @example\n * // Basic composition of stages\n * const validateUser: PipelineStage<UserContext> = compose([\n *   validateEmail,\n *   validatePassword,\n *   validateAge\n * ]);\n *\n * @example\n * // Using mutation mode for performance\n * const processBigData: PipelineStage<DataContext> = compose([\n *   loadData,\n *   transformData,\n *   aggregateResults\n * ], { mutate: true });\n *\n * @example\n * // Error handling in composed stages\n * const processOrder: PipelineStage<OrderContext> = compose([\n *   validateOrder,\n *   checkInventory,\n *   processPayment,\n *   generateInvoice\n * ]);\n *\n * const result = await processOrder(orderContext);\n * if (result.ok) {\n *   // All stages completed successfully\n *   console.log('Order processed:', result.value);\n * } else {\n *   // One of the stages failed\n *   console.error('Processing failed:', result.error);\n * }\n *\n * @example\n * // Nested composition\n * const validateUser = compose([checkEmail, checkPassword]);\n * const processUser = compose([validateUser, createProfile]);\n * const completeRegistration = compose([\n *   processUser,\n *   sendWelcomeEmail,\n *   notifyAdmin\n * ]);\n *\n * @example\n * // With type-specific context\n * interface UserContext extends PipelineContext {\n *   email: string;\n *   profile?: UserProfile;\n *   validationStatus?: boolean;\n * }\n *\n * const userPipeline = compose<UserContext>([\n *   validateUserData,\n *   enrichUserProfile,\n *   finalizeUser\n * ]);\n *\n * @remarks\n * By default, the compose function creates a new context object for each stage\n * using structured cloning. This ensures immutability but may impact performance\n * with large contexts. Use the mutate option if performance is critical and\n * you can safely mutate the context.\n *\n * Error handling is automatic - if any stage returns a failure Result or throws\n * an error, the composed pipeline immediately returns that failure without\n * executing remaining stages.\n *\n * @see {@link PipelineStage} - Individual stage type\n * @see {@link PipelineContext} - Context type\n * @see {@link Result} - Return type for pipeline stages\n */\nconst compose = ((stages, { mutate } = {}) =>\n\tasync (context) => {\n\t\tlet currentContext = mutate === true ? context : structuredClone(context);\n\n\t\tfor (const stage of stages) {\n\t\t\ttry {\n\t\t\t\tconst result = await stage(currentContext);\n\n\t\t\t\tif (result.ok) {\n\t\t\t\t\tcurrentContext =\n\t\t\t\t\t\tmutate === true ? Object.assign(currentContext, result.value) : result.value;\n\t\t\t\t} else {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\treturn failure(error);\n\t\t\t}\n\t\t}\n\n\t\treturn success(currentContext);\n\t}) satisfies Compose;\n\nexport default compose;\n","import type { Result } from '$types/result.js';\n\n/**\n * Extracts the value from a `Result` type or throws the error if it's a\n * failure.\n * This utility function converts the `Result` type back into the standard\n * TypeScript success/throw pattern. It's useful when you need to interact with\n * code that expects traditional error handling or when you're at a boundary\n * where you want to handle errors through the try/catch mechanism.\n *\n * @template T - The type of the success value\n * @template E - The type of the error value\n * @param result - The Result object to resolve\n * @returns The value if Result is successful\n * @throws The error value if Result is a failure\n *\n * @example\n * // Successful case\n * const successResult: Result<number> = success(42);\n * try {\n *   const value = resolve(successResult); // Returns 42\n *   console.log(value);\n * } catch (error) {\n *   // This block won't execute\n * }\n *\n * @example\n * // Failure case\n * const failureResult: Result<number> = failure(new Error('Process failed'));\n * try {\n *   const value = resolve(failureResult); // Throws Error\n *   // This line won't execute\n * } catch (error) {\n *   console.error('Caught:', error);\n * }\n *\n * @example\n * // Usage at system boundaries\n * async function processUserData(userId: string): Promise<UserData> {\n *   const result = await pipelineProcessor.process({ userId });\n *   // Convert from Result type to traditional try/catch at system boundary\n *   return resolve(result);\n * }\n *\n * @example\n * // With custom error types\n * interface ValidationError {\n *   code: string;\n *   message: string;\n * }\n * const result: Result<string, ValidationError> = failure({\n *   code: 'INVALID',\n *   message: 'Invalid input'\n * });\n * try {\n *   resolve(result); // Throws ValidationError\n * } catch (error) {\n *   // error will be ValidationError type\n * }\n *\n * @see {@link Result} - The `Result` type this function processes\n * @see {@link success} - Creates a successful `Result`\n * @see {@link failure} - Creates a failure `Result`\n */\nconst resolve: <T, E>(result: Result<T, E>) => T = (result) => {\n\tif (result.ok) {\n\t\treturn result.value;\n\t} else {\n\t\tthrow result.error;\n\t}\n};\n\nexport default resolve;\n"]}